set Statements <- make Statement array(0);

function Parse()
{
    Pointer <- 0;
    while (~Cur()->Type != "EOF")
    {
        Skip();

        if (~Cur()->Type = "funckw")
        {
            Statements->Push(ParseFunction());
        }
        else if (~Cur()->Type = "EOF")
        {
            return;
        }
        else
        {
            Print("[!] Only functions are allowed globally! Got: " + ~Cur()->Type + " [Line: " + string(GetLineNum(~Cur()->Pos)) + "]");
            die(0);
        }
    }
}

function ParseExpression() Token
{
    Skip();
    if (~Cur()->Type = "string") return Consume("string");
    if (~Cur()->Type = "number") return Consume("number");
    if (~Cur()->Type = "identifier") return Consume("identifier");
    return make Token("nil", "", 0);
}

function ParseFunction() Statement
{
    var funckw <- Consume("funckw");
    var args <- make any array(0);

    args->Push(Consume("identifier"));
    Consume("openparenthesis");

    if (~Cur()->Type = "identifier")
        args->Push(ParseParameters());

    Consume("closeparenthesis");
    Consume("colon");
    args->Push(Consume("identifier"));
    args->Push(ParseBlockStatement());

    return make Statement(funckw->Value, args);
}

function ParseArguments() Statement
{
    var args <- make any array(0);

    while (true)
    {
        Skip();
        if (~Cur()->Type = "EOF") { Print("[!] Unterminated Parenthesis!" + " [Line: " + string(GetLineNum(~Cur()->Pos)) + "]"); die(0); }
        if (~Cur()->Type = "closeparenthesis") { break; }
        args->Push(ParseExpression());

        Skip();

        if (~Cur()->Type != "closeparenthesis") Consume("comma");
    }

    return make Statement("args", args);
}

function ParseParameters() Statement
{
    var args <- make any array(0);

    while (true)
    {
        Skip();
        if (~Cur()->Type = "EOF") { Print("[!] Unterminated Parenthesis!" + " [Line: " + string(GetLineNum(~Cur()->Pos)) + "]"); die(0); }
        if (~Cur()->Type = "closeparenthesis") { break; }

        args->Push(Consume("identifier"));
        args->Push(Consume("colon"));
        args->Push(Consume("identifier"));

        Skip();

        if (~Cur()->Type != "closeparenthesis") Consume("comma");
    }

    return make Statement("params", args);
}

function ParseBlockStatement() Statement
{
    Consume("openbrace");
    var args <- make any array(0);

    while (true)  
    {
        Skip();

        if (~Cur()->Type = "EOF") { Print("[!] Unterminated CodeBlock!" + " [Line: " + string(GetLineNum(~Cur()->Pos)) + "]"); die(0); }  
        if (~Cur()->Type = "closebrace") { break; }  

        args->Push(ParseStatement());
    }

    Consume("closebrace");

    return make Statement("block", args);
}

function ParseStatement() Statement
{
    Skip();
    if (~Cur()->Type = "identifier" && ~Pek(1)->Type = "openparenthesis")
        return ParseCall();
    else if (~Cur()->Type = "returnkw")
        return ParseReturn();

    Print("[!] Exprected Statement, got: " + ~Cur()->Type + " [Line: " + string(GetLineNum(~Cur()->Pos)) + "]");
    die(0);
    return make Statement("nil", make any array(0));
}

function ParseCall() Statement
{
    var args <- make any array(0);
    args->Push(Consume("identifier"));
    Consume("openparenthesis");
    args->Push(ParseArguments());
    Consume("closeparenthesis");
    Consume("semicolon");

    return make Statement("call", args);
}

function ParseReturn() Statement
{
    var returnkw <- Consume("returnkw");
    var args <- make any array(0);
    args->Push(ParseExpression());
    Consume("semicolon");

    return make Statement(returnkw->Value, args);
}

function Cur() Token { return Pek(0); }
function Pek(offset int) Token { return Tokens[Pointer + offset] }
function Skip() { while (~Cur()->Type = "whitespace" || ~Cur()->Type = "comment") { Step(1); } }
function Consume(name string) Token
{ 
    Skip();
    if (~Cur()->Type = name)
    {
        Step(1);
        return Pek(-1);
    }
    else
    {
        Print("[!] Exprected Token " + name + " but got: " + ~Cur()->Type + " [Line: " + string(GetLineNum(~Cur()->Pos)) + "]");
        die(0);
    }
    return Token(nil);
}